use std::{fs, io};
use std::path::PathBuf;

const TEMP_GEN_DIR: &str = "gen";
const DIR: &str = "protos";
const EXT: &str = ".proto";
const BANNER: &str = "\nDO NOT MODIFY!!!\ngenerated by build.rs ";

fn _main() -> Result<(), Box<dyn std::error::Error>> {
    Ok(())
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let _ = fs::create_dir(TEMP_GEN_DIR);
    let _ = fs::remove_dir_all(format!("src/{}", TEMP_GEN_DIR).as_str());
    let _ = fs::create_dir(format!("src/{}", TEMP_GEN_DIR).as_str());
    let mut mf = format!("/* {} */\n", BANNER);
    for file in fs::read_dir(DIR)? {
        let f = file.unwrap().file_name();
        let f = f.to_str().unwrap_or("");
        if f.ends_with(EXT) {
            let f = f[0..f.len() - EXT.len()].to_string();
            let _ = do_build(f.as_str())?;
            mf.push_str(format!("pub mod {};\n", f).as_str())
        }
    }
    let _ = fs::write(format!("src/{}/mod.rs", TEMP_GEN_DIR).as_str(), mf)?;
    let _ = fs::remove_dir_all(TEMP_GEN_DIR);
    Ok(())
}

/// Build grpc tonic from protos dir to gen,
/// than patch and copy to src
fn do_build(name: &str) -> io::Result<()> {
    let  file = format!("{}{}", name, EXT);
    let  dest = format!("src/{}/{}.rs", TEMP_GEN_DIR, name);
    println!("building: {} to {}", file, dest);

    let _ = tonic_build::configure()
        .type_attribute(".", "#[derive(serde::Serialize, serde::Deserialize)]")
        .out_dir(PathBuf::from(TEMP_GEN_DIR))
        .compile(&[file.as_str()], &[DIR])?;

    match fs::read_to_string(format!("{}/{}.rs", TEMP_GEN_DIR, name)) {
        Ok(mut contents) => {

            contents.insert_str(0, format!("/* {} from '{}/{}' \
                into tempdir: '{}', than moved to '{}' \n*/\n", BANNER, DIR, file, TEMP_GEN_DIR, dest).as_str());

            // patch for timeout connection
            patch(&mut contents, "connect<D>(", "d: core::time::Duration, ", false);
            patch(&mut contents, ".connect()", ".connect_timeout(d)", true);
            uncomment(&mut contents, "serde(skip)");
            comment(&mut contents, "pub mod cfg_tabl", "#[derive(serde::");

            let _ = fs::write(dest.as_str(), contents)?;
            println!("wrote: {}", dest);
        }
        Err(e) => {
            println!("patching error: {} {}", dest, e);
        }
    }
    Ok(())
}

/// :( no configure attribute found to modify this:
fn patch(cnt: &mut String, pattern: &str, append: &str, prepend: bool) {
    if let Some(i) = cnt.find(pattern) {
        cnt.insert_str(i + if prepend { 0 } else { pattern.len() }, append);
    }
}

/// uncomment comments, remove backslash
fn uncomment(cnt: &mut String, pattern: &str){
    let min_pat = pattern.len() * 2;
    let mut begin = 0;
    loop {
        if begin >= cnt.len() - min_pat { return; }
        match cnt[begin..].find(pattern) {
            None => { return; },
            Some(x) => {
                match cnt[begin..begin+x].rfind("///") {
                    None => {
                        begin += x + min_pat;
                    }
                    Some(r) => {
                        for _ in 0..3 { cnt.remove(begin + r); }

                        loop {
                            match cnt[begin..begin + x + min_pat].find("\\") {
                                None => { break; },
                                Some(i)  => {
                                    cnt.remove(begin + i);
                                }
                            }
                        }

                        begin += x + min_pat;
                    }
                }
            }
        }
    }
}


/// comment derive inserted by tonic_build for all fields
fn comment(cnt: &mut String, pub_mod: &str, pattern: &str) -> usize {

    match cnt.find(pub_mod) {
        None => 0,
        Some(x) => {
            match cnt[x..].find(pattern) {
                None => 0,
                Some(y) => {
                    cnt.insert_str(x + y, "// ");
                    y + 10
                }
            }
        }
    }

}
